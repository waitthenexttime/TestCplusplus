# 239. 滑动窗口最大值

## 优先队列

```c++
class Solution
{
public:
    vector<int> maxSlidingWindow(vector<int> &nums, int k)
    {
        int n = nums.size();
        priority_queue<pair<int, int>> q;
        for (int i = 0; i < k; i++)
        {
            q.emplace(nums[i], i);
        }
        vector<int> ans = {q.top().first};
        for (int i = k; i < n; i++)
        {
            q.emplace(nums[i], i);
            while (q.top().second <= i - k)
            {
                q.pop();
            }
            ans.push_back(q.top().first);
        }
        return ans;
    }
};
```

用最大堆写的最大问题就是不知道何时将最大值弹出，因为是滑动窗口，所以你堆中的最大值可能不在窗口中。该解法的巧妙之处就在于使用`pair<int, int>`存储元素值与下标。然后在每次滑动窗口返回最大值前，先通过判断最大值下标是否在滑动窗口中，不在的都先剔除。解法十分优美！

## 单调队列

#### deque

```c++
#include <deque>
int main()
{
    deque<int> q;
    for (int i = 0; i < 5; i++)
    {
        q.push_back(i);
    }
    for (int it : q)
    {
        cout << it << " ";
    }
    q.pop_back();
    cout << endl;
    for (int it : q)
    {
        cout << it << " ";
    }
    cout<<endl;
    q.push_front(1000);
    for (int it : q)
    {
        cout << it << " ";
    }
    cout<<endl;
    q.pop_front();
    for (int it : q)
    {
        cout << it << " ";
    }
    cout<<endl;
    system("pause");
    return 0;
}
/* 
0 1 2 3 4
0 1 2 3
1000 0 1 2 3
0 1 2 3 
*/
```

优势在于有`pop_front`和`push_front`，可以对队首元素进行方便的操作。

